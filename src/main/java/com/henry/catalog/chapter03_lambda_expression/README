给方法传递封装了行为的参数；
手段1：匿名类；
手段2：lambda表达式；

是什么？
    一种技术
作用？
    用来表示 可传递的匿名函数
特征？
    1 没有名称；
    2 有参数列表、函数主体、返回类型，以及异常列表（如果有的话）。
    3 不属于某个类型，可以单独使用；
    4 作为一等公民，可以：作为参数传递给方法、存储在变量中(How?)
    5 简洁(因为lambda表达式只写出了真正需要传递的代码） - 这是代码层面上的效果
应用？
    减少代码中的冗余语法代码，使代码表意更加清晰，而且更简洁。
用法？
    在需要传递行为的地方，直接编写lambda表达式 来 表示需要传递的行为。
demo:
    Comparator<Apple> byWeight = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

===
编写lambda表达式的语法：
    1 参数列表
        (Apple a1, Apple a2)
    2 箭头
        ->
    3 Lambda主体
        a1.getWeight().compareTo(a2.getWeight()) // 该主体的返回值 也就是 lambda表达式的值。

语句 VS 表达式
语句：
    return xxx; // 这是一个控制流语句，用于控制执行流程
表达式：
    "Iron Man"; // 这是一个表达式，用于求值 这里求得的值就是 “Iron Man”

where & how？
用法1：作为方法的参数，传递给/绑定到 某一个类型的变量(比如上面的 Comparator<Apple>类型)；
用法2：可以直接赋值给某个类型的变量上；

对于以上两种用法，有一个关键问题是：lambda表达式 是如何与 “某一类型的变量”对应的呢？ aka where
答：Java8中提供的方案 - 函数式接口。
原理：匹配函数描述符；

---
作用：支持lambda表达式的使用；
特征：就只有一个抽象方法（不管其他的因素）；
小伙伴：Lambda表达式；
用法：
    1 使用Lambda表达式 来 为函数式接口的抽象方法提供具体实现 - 特征：直接内联使用 aka 使用时直接编写lambda表达式即可(不需要先声明，再初始化...)；
    2 把lambda表达式 视为 函数式接口某个具体实现的一个实例；

---
note 函数式接口中的抽象方法 就能够代表 函数式接口（因为只有它一个抽象方法）；

函数描述符: 函数式接口中抽象方法的签名。
应用：支持 lambda表达式 与 某一类型变量 之间的对应/映射/绑定。
示例：
    lambda表达式： () -> void   参数列表为空、返回void的函数
    Runnable接口run()方法的函数描述符：  void run();
    两者完全对应，所以就可以把 () -> void这个lambda表达式 用在 任何可以使用Runnable接口的地方。

    // 使用Runnable接口的地方
    public void process(Runnable r) {
        r.run()
    }

    // 传入lambda表达式
    process(() -> System.out.println("Hello from lambda"));
特征：
    lambda表达式的写法可以是不同的，但只要它的签名匹配 抽象方法的函数描述符即可使用它来...

---
方法引用

是：一种技术；
作用：作为 lambda表达式的一种快捷写法；
特征：
    1 只适用于 lambda表达式有“直接调用这个方法”的语义的情况；
    2 在使用方法引用时，并不是在进行方法调用 - 所以不需要添加括号；
    3 相比于lambda表达式 代码更加简洁，也更加易读。
应用：根据现有的方法实现 来 创建lambda表达式；
用法：
    把lambda表达式 重构成为 等价的方法引用；
    <目标引用>::<方法名称>
简单理解：
    方法引用 是 仅仅涉及单个方法的lambda表达式的语法糖。
分类：
    1 指向静态方法的 方法引用；
    2 指向 任意类型实例方法的 方法引用；
    3 指向 现有对象的实例方法的 方法引用。
示例：
    lambda表达式 (Apple a) -> a.getWeight()
    方法引用    Apple::getWeight

call it a chapter~










